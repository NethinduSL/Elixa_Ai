<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="Interactive AI with animated eyes that responds to your messages">
  <title>Elixa AI</title>
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css" rel="stylesheet">
  <style>
      @import url('https://fonts.googleapis.com/css2?family=Source+Code+Pro:wght@400;500&display=swap');
      
    :root {
      --primary-color: #1a1a1a;
      --secondary-color: #4a4a4a;
      --accent-color: #0077cc;
      --text-color: #333;
      --light-gray: #f0f0f0;
      --border-radius: 8px;
      --transition-speed: 0.2s;
    }

    body {
      margin: 0;
      background: white;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      font-family: 'Source Code Pro', monospace;
      color: var(--text-color);
      padding: 20px;
      box-sizing: border-box;
    }

    h1 {
      color: var(--primary-color);
      margin-bottom: 40px;
    }
    
    .uda {
      font-size: 20px;
      position: absolute;
      top: 10px;
      cursor: pointer;
    }
    
    .dropdown {
      position: absolute;
      top: 40px;
      background: white;
      border: 1px solid var(--light-gray);
      border-radius: var(--border-radius);
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
      z-index: 100;
      display: none;
      min-width: 200px;
    }
    
    .dropdown.show {
      display: block;
    }
    
    .dropdown-item {
      padding: 10px 15px;
      cursor: pointer;
      transition: background-color var(--transition-speed);
    }
    
    .dropdown-item:hover {
      background-color: var(--light-gray);
    }
    
    .dropdown-item.active {
      background-color: var(--accent-color);
      color: white;
    }

    .eyes-container {
      display: flex;
      height: 80px;
      gap: 100px;
      margin-bottom: 40px;
      position: relative;
    }

    .eye {
      width: 150px;
      height: 70px;
      background: var(--primary-color);
      border-radius: 10px;
      transition: all var(--transition-speed) ease;
      position: relative;
      overflow: hidden;
    }

.eye::before {
  content: '';
  position: absolute;
  width: 40px;
  height: 40px;
  background: white;
  border-radius: 40%;
  top: calc(50% + var(--eye-offset-y, 0px));
  left: calc(50% + var(--eye-offset-x, 0px));
  transform: translate(-50%, -50%);
  opacity: 0.2;
}


    .eye.closed {
      height: 20px;
      margin-top: 40px;
      border-radius: 50px;
    }

    .chat-box {
      display: flex;
      gap: 10px;
      align-items: center;
      width: 100%;
      max-width: 500px;
    }

    input[type="text"] {
      padding: 12px 15px;
      font-size: 1rem;
      border: none;
      border-radius: var(--border-radius);
      width: 100%;
      transition: border-color 0.2s ease;
    }

    input[type="text"]:focus {
      outline: none;
    }

    button {
      padding: 12px 20px;
      font-size: 1rem;
      background-color: var(--primary-color);
      color: white;
      border: none;
      border-radius: var(--border-radius);
      cursor: pointer;
      transition: background-color 0.2s ease, transform 0.1s ease;
      white-space: nowrap;
    }

    button:hover {
      background-color: var(--secondary-color);
    }

    button:active {
      transform: scale(0.98);
    }

    .response {
      margin-top: 30px;
      max-width: 500px;
      text-align: center;
      padding: 15px;
      border-radius: var(--border-radius);
      min-height: 60px;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-direction: column;
    }

    .response b {
      font-weight: bold;
      color: var(--primary-color);
    }

    .loading {
      position: relative;
    }

    .loading::after {
      content: '';
      position: absolute;
      width: 20px;
      height: 20px;
      border: 3px solid rgba(0, 0, 0, 0.1);
      border-top-color: var(--primary-color);
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-left: 10px;
    }

    .stop-button {
      margin-top: 15px;
      background-color: #ff4444;
      padding: 8px 15px;
      font-size: 0.9rem;
    }

    .stop-button:hover {
      background-color: #cc0000;
    }

    .menu-content {
      text-align: left;
      width: 100%;
    }

    .menu-content img {
      max-width: 100%;
      border-radius: 8px;
      margin: 10px 0;
    }

    .menu-content button {
      display: block;
      width: 100%;
      margin: 5px 0;
      text-align: left;
      padding: 10px;
      background-color: var(--light-gray);
      color: var(--text-color);
    }

    .menu-content button:hover {
      background-color: #e0e0e0;
    }

    .generated-image {
      max-width: 100%;
      border-radius: 12px;
      margin-top: 15px;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    @media (max-width: 600px) {
      .eyes-container {
        gap: 50px;
      }
      
      .eye {
        width: 80px;
        height: 80px;
      }
      
      .eye.closed {
        height: 16px;
        margin-top: 32px;
      }
      
      .chat-box {
        flex-direction: column;
      }
      
      button {
        width: 100%;
      }
    }
  </style>
</head>
<body>
    <div class="uda" id="dropdownToggle">
      <i class="fa-solid fa-caret-down"></i>
      <span id="currentModel">Elixa </span>
    </div>
    <div class="dropdown" id="dropdownMenu">
        <div class="dropdown-item" data-model="elixa">Elixa<i class="fa-solid fa-heart"></i></div>
      <div class="dropdown-item" data-model="gemini">Gemini</div>
      <div class="dropdown-item" data-model="gemini2">Gemini<i class="fa-solid fa-plus"></i></div>
      <div class="dropdown-item" data-model="llama">Llama</div>
      <div class="dropdown-item" data-model="jeeves-chat">Jeeves</div>
            
      <div class="dropdown-item" data-model="aoyo">Aoyo</div>
      <div class="dropdown-item" data-model="maths">Maths</div>
      <div class="dropdown-item" data-model="flux">Flux <i class="fa-solid fa-image"></i></div>
      <div class="dropdown-item" data-model="magicstudio">Magicstudio <i class="fa-solid fa-image"></i></div>
    </div>
  
  <h1>Elixa AI</h1>
  
  <div class="eyes-container">
    <div class="eye" id="eye1"></div>
    <div class="eye" id="eye2"></div>
  </div>

  <div class="chat-box">
    <input type="text" id="userInput" placeholder="Talk to AI..." aria-label="Type your message here" />
    <button id="sendButton" onclick="sendMessage()">Send</button>
  </div>

  <div class="response" id="response"></div>
  <button class="stop-button" id="stopButton" style="display: none;"><i class="fa-solid fa-circle-stop"></i></button>

  <script>
      
  // <div class="dropdown-item" data-model="deep">Deepseek</div> 
      
      
      
    const eye1 = document.getElementById('eye1');
    const eye2 = document.getElementById('eye2');
    const sendButton = document.getElementById('sendButton');
    const userInput = document.getElementById('userInput');
    const responseDiv = document.getElementById('response');
    const dropdownToggle = document.getElementById('dropdownToggle');
    const dropdownMenu = document.getElementById('dropdownMenu');
    const currentModelElement = document.getElementById('currentModel');
    const dropdownItems = document.querySelectorAll('.dropdown-item');
    const stopButton = document.getElementById('stopButton');

    // Custom responses and actions
    const customResponses = {
      "menu": {
        action: "showHTML",
        content: `
          <div class="menu-content">
            <h3>Elixa AI Menu</h3>
            <p>Select an option below or type your question:</p>
            <button onclick="handleMenuOption('features')">Features</button>
            <button onclick="handleMenuOption('commands')">Available Commands</button>
            <button onclick="handleMenuOption('about')">About Elixa</button>
            <button onclick="handleMenuOption('help')">Help</button>
            <img src="https://placehold.co/400x200?text=Elixa+AI" alt="Elixa AI">
          </div>
        `
      },
      "features": {
        action: "showHTML",
        content: `
          <div class="menu-content">
            <h3>Elixa AI Features</h3>
            <ul>
              <li>Natural language processing</li>
              <li>Multiple AI models</li>
              <li>Interactive eyes</li>
              <li>Image generation</li>
              <li>Math problem solving</li>
            </ul>
            <p>Type <b>menu</b> to return to the main menu.</p>
          </div>
        `
      },
      "commands": {
        action: "showHTML",
        content: `
          <div class="menu-content">
            <h3>Available Commands</h3>
            <ul>
              <li><b>menu</b> - Show this menu</li>
              <li><b>help</b> - Get help</li>
              <li><b>about</b> - Learn about Elixa</li>
              <li><b>clear</b> - Clear the chat</li>
            </ul>
          </div>
        `
      },
      "about": {
        action: "showText",
        content: "Elixa is an advanced AI assistant designed by Nethindu Thaminda Kodithuwakku to help with various tasks. It combines multiple AI models to provide the best possible responses."
      },
      "help": {
        action: "showText",
        content: "You can ask me anything! Try questions about science, history, or request images. Type 'menu' to see options."
      },
      "clear": {
        action: "clearChat",
        content: ""
      }
    };

    // AI models configuration with response handling instructions
    const aiModels = {
      elixa: {
        name: "Elixa",
        endpoint: "https://bk9.fun/ai/gemini?q=",
        responseType: "text", // text, image, or direct
        responsePath: "BK9", // Path to the response data in JSON
        processResponse: function(data) {
          // Default text processing
          let response = Array.isArray(data[this.responsePath]) ? 
                         data[this.responsePath].join(" ") : 
                         data[this.responsePath];
          return replaceAINames(response);
        }
      },
      gemini: {
        name: "Gemini",
        endpoint: "https://bk9.fun/ai/gemini?q=",
        responseType: "text",
        responsePath: "BK9",
        processResponse: function(data) {
          let response = Array.isArray(data[this.responsePath]) ? 
                         data[this.responsePath].join(" ") : 
                         data[this.responsePath];
          return replaceAINames(response);
        }
      },
      
      deep: {
        name: "Deepseek",
        endpoint: "https://bk9.fun/ai/deepseek-r1?q=",
        responseType: "text",
        responsePath: "BK9.content",
        processResponse: function(data) {
          let response = Array.isArray(data[this.responsePath]) ? 
                         data[this.responsePath].join(" ") : 
                         data[this.responsePath];
          return response;
        }
      },
      
      
      llama: {
        name: "Llama",
        endpoint: "https://bk9.fun/ai/llama?q=",
        responseType: "text",
        responsePath: "BK9",
        processResponse: function(data) {
          let response = Array.isArray(data[this.responsePath]) ? 
                         data[this.responsePath].join(" ") : 
                         data[this.responsePath];
          return replaceAINames(response);
        }
      },
      "jeeves-chat": {
        name: "Jeeves",
        endpoint: "https://bk9.fun/ai/jeeves-chat?q=",
        responseType: "text",
        responsePath: "BK9",
        processResponse: function(data) {
          let response = Array.isArray(data[this.responsePath]) ? 
                         data[this.responsePath].join(" ") : 
                         data[this.responsePath];
          return replaceAINames(response);
        }
      },
      maths: {
        name: "Maths",
        endpoint: "https://bk9.fun/ai/mathssolve?q=",
        responseType: "text",
        responsePath: "BK9",
        processResponse: function(data) {
          let response = Array.isArray(data[this.responsePath]) ? 
                         data[this.responsePath].join(" ") : 
                         data[this.responsePath];
          return replaceAINames(response);
        }
      },
      
      aoyo: {
        name: "Aoyo",
        endpoint: "https://bk9.fun/ai/Aoyo?q=",
        responseType: "text",
        responsePath: "BK9",
        processResponse: function(data) {
          let response = Array.isArray(data[this.responsePath]) ? 
                         data[this.responsePath].join(" ") : 
                         data[this.responsePath];
          return replaceAINames(response);
        }
      },
      
      
      gemini2: {
        name: "Gemini+",
        endpoint: "https://bk9.fun/ai/google-thinking?q=",
        responseType: "text",
        responsePath: "BK9",
        processResponse: function(data) {
          let response = Array.isArray(data[this.responsePath]) ? 
                         data[this.responsePath].join(" ") : 
                         data[this.responsePath];
          return replaceAINames(response);
        }
      },
      
      
      
      flux: {
        name: "flux",
        endpoint: "https://bk9.fun/ai/fluximg?q=",
        responseType: "image",
        responsePath: "BK9[0]", // First image in array
        processResponse: function(data) {
          // For images, we return the URL directly
          const pathParts = this.responsePath.replace(/\]/g, '').split('[');
          let result = data;
          for (const part of pathParts) {
            if (part) result = result[part];
          }
          return result;
        }
      },
      magicstudio: {
        name: "magicstudio",
        endpoint: "https://bk9.fun/ai/magicstudio?prompt=",
        responseType: "direct", // Special handling - don't fetch, use URL directly
        processResponse: function(prompt) {
          // For direct image generation, we construct the image URL
          return `${this.endpoint}${encodeURIComponent(prompt)}`;
        }
      }
    };

    let currentModel = "elixa";
    let typingInterval = null;
    let isTyping = false;
    let currentRequest = null;

    // Toggle dropdown menu
    dropdownToggle.addEventListener('click', () => {
      dropdownMenu.classList.toggle('show');
    });

    // Close dropdown when clicking outside
    document.addEventListener('click', (e) => {
      if (!dropdownToggle.contains(e.target) && !dropdownMenu.contains(e.target)) {
        dropdownMenu.classList.remove('show');
      }
    });

    // Handle model selection
    dropdownItems.forEach(item => {
      item.addEventListener('click', () => {
        const model = item.dataset.model;
        currentModel = model;
        currentModelElement.textContent = aiModels[model].name;
        
        // Update active state
        dropdownItems.forEach(i => i.classList.remove('active'));
        item.classList.add('active');
        
        dropdownMenu.classList.remove('show');
      });
    });

    // Enhanced blinking animation
    function blinkEyes() {
      eye1.classList.add('closed');
      eye2.classList.add('closed');
      setTimeout(() => {
        eye1.classList.remove('closed');
        eye2.classList.remove('closed');
      }, 150);
    }

    // More natural blinking pattern
    function scheduleBlink() {
      const baseTime = 2000 + Math.random() * 3000;
      const variance = Math.random() > 0.7 ? 1000 : 0; // occasional double blinks
      setTimeout(() => {
        blinkEyes();
        scheduleBlink();
      }, baseTime + variance);
    }

    // Start blinking
    scheduleBlink();

    // Enhanced eye tracking (follows mouse)
    
    
    const eyeball1 = document.querySelector('.eye#eye1');
const eyeball2 = document.querySelector('.eye#eye2');

function moveEyeballs(x, y) {
  // Get centers of both eyes
  const rect1 = eyeball1.getBoundingClientRect();
  const rect2 = eyeball2.getBoundingClientRect();

  const centerX = (rect1.left + rect1.width / 2 + rect2.left + rect2.width / 2) / 2;
  const centerY = (rect1.top + rect1.height / 2 + rect2.top + rect2.height / 2) / 2;

  const dx = x - centerX;
  const dy = y - centerY;

  const maxDistance = 10;
  const angle = Math.atan2(dy, dx);
  const distance = Math.min(maxDistance, Math.hypot(dx, dy));

  const offsetX = Math.cos(angle) * distance;
  const offsetY = Math.sin(angle) * distance;

  // Apply same offset to both eyes
  [eyeball1, eyeball2].forEach(eye => {
    eye.style.setProperty('--eye-offset-x', `${offsetX}px`);
    eye.style.setProperty('--eye-offset-y', `${offsetY}px`);
  });
}

document.addEventListener('mousemove', e => moveEyeballs(e.pageX, e.pageY));
document.addEventListener('touchmove', e => {
  if (e.touches.length > 0) {
    const touch = e.touches[0];
    moveEyeballs(touch.pageX, touch.pageY);
  }
}, { passive: true });

      
      
      

    function replaceAINames(text) {
      if (!text) return "";
      const aiNames = ["BK9", "Gemini", "AI", "Assistant", "Chatbot"];
      let result = text;
      aiNames.forEach(name => {
        const regex = new RegExp(name, 'gi');
        result = result.replace(regex, 'Elixa');
      });
      return result;
    }

    // Convert **text** to bold
    function formatTextWithBold(text) {
      if (!text) return "";
      // Replace **text** with <b>text</b>
      return text.replace(/\*\*(.*?)\*\*/g, '<b>$1</b>');
    }

    // Handle menu options
    window.handleMenuOption = function(option) {
      if (customResponses[option]) {
        processCustomResponse(option);
      }
    };

    // Process custom responses
    function processCustomResponse(key) {
      const response = customResponses[key];
      
      if (response.action === "showHTML") {
        responseDiv.innerHTML = response.content;
      } 
      else if (response.action === "showText") {
        responseDiv.innerHTML = formatTextWithBold(response.content);
      }
      else if (response.action === "clearChat") {
        responseDiv.innerHTML = '';
      }
    }

    // Stop the current response
    function stopResponse() {
      if (typingInterval) {
        clearInterval(typingInterval);
        typingInterval = null;
      }
      isTyping = false;
      stopButton.style.display = 'none';
      
      // Abort any ongoing fetch request
      if (currentRequest) {
        currentRequest.abort();
        currentRequest = null;
      }
    }

    // Display an image response
    function displayImage(url) {
      responseDiv.innerHTML = '';
      const img = document.createElement('img');
      img.src = url;
      img.alt = 'Generated Image';
      img.className = 'generated-image';
      responseDiv.appendChild(img);
    }

    // Improved message handling
    async function sendMessage() {
      const message = userInput.value.trim().toLowerCase();
      if (!message) {
        userInput.focus();
        return;
      }

      // Check for custom responses first
      if (customResponses[message]) {
        processCustomResponse(message);
        userInput.value = "";
        userInput.focus();
        return;
      }

      // Visual feedback
      sendButton.disabled = true;
      responseDiv.innerHTML = '<span class="loading">Thinking</span>';
      stopButton.style.display = 'block';
      
      try {
        // Blink eyes when thinking
        blinkEyes();
        
        const modelConfig = aiModels[currentModel];
        
        // Special handling for direct image generation (like magicstudio)
        if (modelConfig.responseType === "direct") {
          const imageUrl = modelConfig.processResponse(message);
          displayImage(imageUrl);
          userInput.value = "";
          userInput.focus();
          return;
        }
        
        const endpoint = modelConfig.endpoint + encodeURIComponent(message);
        
        // Create an AbortController for the fetch request
        const controller = new AbortController();
        currentRequest = controller;
        
        const response = await fetch(endpoint, {
          signal: controller.signal
        });
        
        if (!response.ok) {
          throw new Error(`API request failed with status ${response.status}`);
        }
        
        const result = await response.json();
        currentRequest = null;
        
        // Process the response according to model configuration
        if (modelConfig.responseType === "image") {
          const imageUrl = modelConfig.processResponse(result);
          displayImage(imageUrl);
        } 
        else if (modelConfig.responseType === "text") {
          let processedText = modelConfig.processResponse(result);
          processedText = formatTextWithBold(processedText);
          typeResponse(processedText);
        }
        
      } catch (error) {
        if (error.name !== 'AbortError') {
          console.error('Error:', error);
          responseDiv.textContent = "Oops! Something went wrong. Please try again later.";
        }
      } finally {
        sendButton.disabled = false;
        userInput.value = "";
        userInput.focus();
        stopButton.style.display = 'none';
        currentRequest = null;
      }
    }

    // Typewriter effect for responses
    function typeResponse(text) {
      let i = 0;
      responseDiv.innerHTML = '';
      const speed = 25 + Math.random() * 30; // Variable typing speed
      isTyping = true;
      
      // We'll use a temporary div to properly handle HTML tags
      const tempDiv = document.createElement('div');
      
      typingInterval = setInterval(() => {
        if (i < text.length && isTyping) {
          // Add the next character to our temporary div
          tempDiv.innerHTML = text.substring(0, i+1);
          // Update the actual response div
          responseDiv.innerHTML = tempDiv.innerHTML;
          i++;
          
          // Occasionally blink while "typing"
          if (i % 15 === 0 && Math.random() > 0.7) {
            blinkEyes();
          }
        } else {
          clearInterval(typingInterval);
          typingInterval = null;
          isTyping = false;
          stopButton.style.display = 'none';
        }
      }, speed);
    }

    // Event listeners
    userInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        sendMessage();
      }
    });

    stopButton.addEventListener('click', stopResponse);

    // Initial focus on input
    userInput.focus();
    
    // Set initial active model
    document.querySelector(`.dropdown-item[data-model="${currentModel}"]`).classList.add('active');
  </script>
</body>
  </html>
